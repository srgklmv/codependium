![The Codependium](./static/codependium.jpg)

# The Codependium

Репозиторий для личных заметок.

- [ ] k8s
- [ ] nginx
- [ ] Транзакции в индексы в nosql БД
- [ ] ООП
- [ ] Стандартная библиотека
- [ ] System design
- [ ] Контроль качества разрабатываемых систем
- [ ] Угрозы безопасности
  - [ ] XSS
  - [ ] Injections
  - [ ] CSRF
- [ ] Фреймворки
- [ ] Git
- [ ] Architecture patterns
  - [ ] Чем отличается монолит от микросервисов? Почему монолит и микросервисы могут выглядеть одинаково? А могут ли? 
- [ ] Algorithms and data structures - base level
  - [ ] Векторный поиск
  - [ ] Префиксное дерево
  - [ ] Дерево поиска
    - [ ] балансировка
  - [ ] Графы
- [ ] Computer science essentials
  - [ ] Network protocols
  - [ ] How memory pointers works?
  - [ ] Битовые операции
- [ ] Виды многозадачности.
- [ ] NATS
- [ ] Что такое deadlock? А lifelock? Привести примеры.
- [ ] Что такое cookie и зачем они нужны?
- [ ] Внутреннее устройство Kafka.
  - [ ] За счёт чего достигается высокая производительность? Какой-то аналог lock-файла, append only, только чтение.


## Index

## Golang

- [ ] defer
  - [ ] Как выполняется?
  - [ ] Когда выполняется и в каком порядке?
  - [ ] Как передаются аргументы?
- [ ] What is panics? And fatals? Differences from errors.
- [ ] Flags package.
- [ ] Packages and init functions.
- [ ] What is the point of buffers?
- [ ] Composition and inheritance.
- [ ] Imperative or declarative?
- [ ] Indirection and redirection.
- [ ] Виды многозадачности.
- [ ] sort.Stable <- что значит "stable" тут? Как вообще работает сортировка в Го?
- [ ] Битовые операции в Го
  - [ ] Как хранить ip-адрес в int32?
- [ ] Что делает make? Чем отличается от new?

### Типы данных

- [ ] Ссылочные типы и типы значений – что это?
- [ ] Где в памяти хранятся
- [ ] Добавить принадлежность к comparable для каждого из типов.
- [ ] Способы определения типов данных и их производительность.

#### Общая информация

Встроенные типы данных:

```
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

float32 float64

byte // alias for uint8

rune // alias for int32, representation for a Unicode code point

complex64 complex128

struct

array, slice

map

channel
```

#### Строки

- [ ] ASCII, UTF, Unicode – что это и как относится к хранению строк в Го?

Строки представляют собой массив байт.
Являются неизменяемым типом данных, т.к. вставка бóльшего по размеру в байтах символа 
Юникода невозможна
в условиях неизменяемости базового массива.

Можно взять символ по индексу, но нельзя заменить по нему значение. Пример с
символом, занимающим более одного байта:

```go
	s := "abóba"

	print(string(s[0]))
	print(string(s[1]))
	print(string(s[2]))
	print(string(s[3]))
	print(string(s[4]))
	print(string(s[5]))
	
	// выведет abÃ³ba
```

Итерироваться можно по байтам через индексы (`for i:=0;i<len(s);i++`) или по рунам 
через `for range` :

```go
	s := "abóba"

    for _, v := range s {
        print(string(v))
    }
	
	// выведет abóba
```

Структура строки под капотом:

```go
	type string struct {
		ptr unsafe.Pointer // указатель на начало базового массива, как в массивах и слайсах 
		len int
	}
```

Строки передаются **по значению**.

#### Массивы и слайсы

- [ ] growslise vs nestslicecap differences

Массив представляет собой участок памяти фиксированной длины. При любом варианте объявления
будет аллоцирована память.

```go
    var a [2]int // аллоцирует память с нулевыми значениями типа – [0, 0] 
    a := [2]int{1, 2} // аллоцирует память с переданными значениями – [1, 2] 
    a := [...]int{1, 2, 3} // определит размер самостоятельно, аллоцирует память с переданными значениями – [1, 2, 3] 
```

Массивы передаются **по значению**.

---

Слайсы представляют собой надстройку над массивами:

```go
	type slice struct {
		ptr unsafe.Pointer // указатель на начало базового массива
		len int
		cap int
	}
```

Слайс – один из **ссылочных** типов данных. Т.е., при передаче данных происходит копирование
ссылки, которая ведёт на место в памяти с данными.

По сути, содержимое слайса управляется с помощью длины и указателя на начало базового
массива.

Вместительность обозначает размер базового массива от ячейки по ссылке и до конца. При 
превышении capacity происходит аллокация новой памяти и копирование данных. Вместительность
рассчитывается следующим образом (см. функцию `nextslicecap`):
- При размере до 256 длина нового базового массива удваивается;
- При большем размере происходит расчёт с кэфом 1.25:
```go
    for {
		newcap += (newcap + 3*threshold) >> 2 // вот тут происходит вся магия
		
		if uint(newcap) >= uint(newLen) {
			break
		}
	}
```

#### Мапы

TODO:
- [ ] Описать хэш функции из новой мапы (AES, wyhash)
- [ ] Описать старую мапу подробнее
- [ ] Чем отличается от `sync.Map` и зачем две разные мапы в стандартной либе?

---

Термины:

HOB (high order bits) - старшие (первые) 57 бит от хэша по ключу

LOB (low order bits) - младшие (последние) 7 бит от хэша по ключу

Слот – структура с ключом и значением:

```go
    type slot struct {
        key  typ.Key
        elem typ.Elem
    }
```

Группа – структура с восемью слотами и их метадатой: 

```go
	type group struct {
    	ctrls ctrlGroup
    	slots [abi.SwissMapGroupSlots]slot
    }
```

Таблица – todo! Тут хранятся слоты.

Директория – todo! Тут хранятся таблицы.

TODO: Про таблицу и директорию надо будет добавить про открытую и закрытую адресации,
и в чём заключается выгода их применения для данных кейсов.

---

> ! Старший бит для каждого слота определяет – занят ли слот или нет. Единица – свободен,
> 0 – занят или был занят.

#### Структуры

- [ ] Как хранятся в памяти? Какие особенности аллокации памяти существуют для струтур?
- [ ] Что такое выравнивание структур?
- [ ] Критерии определения порядка полей структур.

#### Каналы

#### Интерфейсы

TODO:
- [ ] Как интерфейс устроен под капотом?
- [ ] Какие есть проблемы производительности при работе с интерфейсами вместо типов?
- [ ] Где хранится структура интерфейса?
- [ ] Где хранится объект, передаваемый через интерфейс?
- [ ] Зачем нужен и чем отличается алиас `any` от пустого интерфейса?
- [ ] Способы определения типа или интерфейса, их производительность.

Интерфейсы являются декларацией методов, необходимых для реализации используемым
типом. 

#### Примитивы синхронизации

- [ ] Какие примитивы синхронизации существуют?

Остальная информация находится в соответствующем разделе.

### Встроенные функции

- [ ] new vs make – в чём разница и какие юзкейсы.
- [ ] Сделать здесь список встроенных функций с кратким описанием.

### Конкурентность

- [ ] Как в Го реализуется конкурентность?
- [ ] Есть ли в языке параллелизм?
- [ ] Какие есть инструменты управления параметрами конкурентности программы?
- [ ] Каналы
  - [ ] Какие бывают?
  - [ ] Для чего используются?
  - [ ] Как устроены под капотом?
  - [ ] Какие существуют оптимизации у каналов?
  - [ ] Как работает select? В каком порядке выбирает?
- [ ] Мьютексы
  - [ ] Какие виды бывают, чем отличаются?
  - [ ] Как устроено ограничение доступа к памяти?
  - [ ] Как работают под капотом?
- [ ] Вейтгруппы
- [ ] Атомики
- [ ] Пакет sync

### Рантайм

- [ ] Горутины
  - [ ] Что это такое?
  - [ ] Чем отличаются от потоков?
- [ ] Планировщик
  - [ ] Как устроена GMP-модель?
- [ ] Сборщик мусора
  - [ ] По какой модели работает?
  - [ ] Когда вызывается?
  - [ ] Какое влияние на программу с точки зрения производительности?
  - [ ] Какие есть инструменты управления сборщиком?
- [ ] Модель памяти
  - [ ] Стек функции и стек горутины – чем отличаются?
  - [ ] Как устроена память в Го?
  - [ ] Куда сохраняются данные и почему?

## Базы данных

- [ ] Колоночные БД

### Реляционные БД

- [ ] Оптимизации запросов
- [ ] Что такое идентифицирующая и неидентифицирующая связь в БД?
- [ ] Анализ производительности запросов и индексов
- [ ] Какие бывают, чем отличаются
- [ ] Масштабирование
  - [ ] Репликация
  - [ ] Шардирование
    - [ ] Как подобрать ключ для разделения таблиц?
  - [ ] Партиционирование
- [ ] Индексы
  - [ ] Какие бывают и для чего применяются?
  - [ ] Минусы и особенности использования индексов.
  - [ ] Как устроены под капотом btree? Что хранится в листьях?
  - [ ] Простые и составные – что это и зачем используется?
- [ ] Уровни нормализации БД

#### ACID

Atomicity (атомарность) – транзакция либо выполняется полностью, либо не выполняется
вообще.

Consistency (консистентность, согласованность) – транзакция приводит данные из согласованного
в согласованное состояние.

Isolation (изоляция) – параллельные транзакции не влияют на результат друг друга.

Durability (устойчивость) – результат завершённой транзакции будет сохранён даже в случае
отказа системы.

#### Уровни изоляции и аномалии

Аномалии:
- Грязное чтение – чтение данных, которые могут быть откатаны.
- Неповторяющееся чтение – чтение данных, которые могут быть изменены другой транзакцией.
- Фантомное чтение – повторное чтение из таблицы, в которой появились новые строки.

#### SQL

- [ ] Схема построения запроса и порядок его выполнения.
- [ ] Джоины
  - [ ] Какие есть, чем отличаются?
  - [ ] Как формируют таблицу под капотом?
  - [ ] Как отличается производительность?
- [ ] Оконные функции
  - [ ] Какие существуют оконные функции?
  - [ ] Перечислить все функции, особенности их вызова, производительность.

### Нереляционные

- [ ] Какие бывают и для чего используются?

## Сети

- [ ] Что такое OSI-модель?
- [ ] TCP
- [ ] IP
- [ ] HTTP/HTTPS
- [ ] SSL/TLS
- [ ] HTTP 1.0 vs 2.0
- [ ] gRPC
- [ ] WebSockets
- [ ] Long polling, SSE

## Web-приложения

- [ ] Архитектура веб-приложений
- [ ] Авторизация
  - [ ] Идентификация, аутентификация, авторизация – что это и чем отличается?
  - [ ] Какие способы авторизации существуют?
  - [ ] OAuth

## Тестирование

Тестирование бэкенд-приложений можно классифицировать по нескольким критериям.

**По типу автоматизации:**
- **Ручные тесты**\
Основными инструментами для бэка является взаимодейстующие приложения (например, фронт или мп),
Postman и Swagger. Суть ясна из названия.

- **Автотесты**\
Те же тесты, но реализованные в коде для автоматического применения локально или в пайпах.
Тут используются либы для написания тестов, моков, создания тестового окружения и т.п.

**По назначению:**

- **Функциональные**\
Проверяют бизнес-логику приложения.

- **Нефункциональные**\
Проверяют производительность, отказоустойчивость, безопасность. 
TODO: Про нефункциональщину можно разузнать побольше и дописать. Относятся ли сюда 
интеграционные тесты?

Для бэкенд-разработчика наиболее актуальными являются смоук-тесты и автотесты.

Для оценки покрытия тестами приложения используется пирамида тестирования. Её суть 
заключается в том, что количество тестов напрямую зависит от уровня их детализации.
Больше всего должно быть написано юнит-тестов. Затем идут интеграционные, затем e2e.

Стоит упомянуть, что хорошей практикой является запуск тестов в **CI/CD** пайплайнах.

**Unit-тесты**
Используются для тестирования одного юнита, т.е. наименьшей рабочей единицы, будь то функция, 
класс или его метод. Есть прикольные вопросы для проверки того, является 
ли тест юнитом:

> - Если тестируемый код натурально общается БД;
> - Или взаимодействует через интернет;
> - Или пользуется файловой системой;
> - Или не может быть запущен параллельно любому другому тесту;
> - Или нужно делать что-либо в окружении, чтобы запустить тесты.
> 
> Если на хотя бы один пункт Вы ответили "да", в таком случае Вы пишете не юнит-тест.

Юнитами покрываем бизнес-логику и утилки. Мокаем внешние слои для запуска.

**Интеграционные тесты**

Используются для проверки взаимодействия приложения с внешними сервисами – БДшками, 
FS, всё, что идёт через инет. Насколько я понимаю, есть разные тактики. Например,
для внешних интеграций проверяется статус-код респонса, а для БД можно также проверять
валидность данных после изменений.

По сути, здесь проверяются только слои, которые взаимодействуют с внешним миром, не 
вся система как в e2e. Для этих тестов необходимо обеспечить окружение.

**End-to-end**

В e2e'шках тестируется вся система полностью. Т.е., для бэкенда флоу представляет собой
деплой на тестовый стенд, где полностью воссоздана система, или такой же полный, но 
локальный деплой и последующие запуски тестов.

