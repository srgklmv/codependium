![The Codependium](./static/codependium.jpg)

# The Codependium

Репозиторий для личных заметок.

## Index

## Golang

### Типы данных

#### Общая информация

Встроенные типы данных:

```
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

float32 float64

byte // alias for uint8

rune // alias for int32, representation for a Unicode code point

complex64 complex128

struct

array, slice

map

channel
```

#### Строки

Строки представляют собой массив байт.
Являются неизменяемым типом данных, т.к. вставка бóльшего по размеру в байтах символа 
Юникода невозможна
в условиях неизменяемости базового массива.

Можно взять символ по индексу, но нельзя заменить по нему значение. Пример с
символом, занимающим более одного байта:

```go
	s := "abóba"

	print(string(s[0]))
	print(string(s[1]))
	print(string(s[2]))
	print(string(s[3]))
	print(string(s[4]))
	print(string(s[5]))
	
	// выведет abÃ³ba
```

Итерироваться можно по байтам через индексы (`for i:=0;i<len(s);i++`) или по рунам 
через `for range` :

```go
	s := "abóba"

    for _, v := range s {
        print(string(v))
    }
	
	// выведет abóba
```

Структура строки под капотом:

```go
	type string struct {
		ptr unsafe.Pointer // указатель на начало базового массива, как в массивах и слайсах 
		len int
	}
```

Строки передаются **по значению**.

#### Массивы и слайсы

Массив представляет собой участок памяти фиксированной длины. При любом варианте объявления
будет аллоцирована память.

```go
    var a [2]int // аллоцирует память с нулевыми значениями типа – [0, 0] 
    a := [2]int{1, 2} // аллоцирует память с переданными значениями – [1, 2] 
    a := [...]int{1, 2, 3} // определит размер самостоятельно, аллоцирует память с переданными значениями – [1, 2, 3] 
```

Массивы передаются **по значению**.

---

Слайсы представляют собой надстройку над массивами:

```go
	type slice struct {
		ptr unsafe.Pointer // указатель на начало базового массива
		len int
		cap int
	}
```

Слайс – один из **ссылочных** типов данных. Т.е., при передаче данных происходит копирование
ссылки, которая ведёт на место в памяти с данными.

По сути, содержимое слайса управляется с помощью длины и указателя на начало базового
массива.

Вместительность обозначает размер базового массива от ячейки по ссылке и до конца. При 
превышении capacity происходит аллокация новой памяти и копирование данных. Вместительность
рассчитывается следующим образом (см. функцию `nextslicecap`):
- При размере до 256 длина нового базового массива удваивается;
- При большем размере происходит расчёт с кэфом 1.25:
```go
    for {
		newcap += (newcap + 3*threshold) >> 2 // вот тут происходит вся магия
		
		if uint(newcap) >= uint(newLen) {
			break
		}
	}
```

#### Мапы

TODO:
- [ ] Описать хэш функции из новой мапы (AES, wyhash)
- [ ] Описать старую мапу подробнее

Термины:
HOB (high order bits) - 


#### Каналы

#### Интерфейсы

#### Примитивы синхронизации

### Встроенные функции

### Конкурентность

### Рантайм


## Тестирование

Тестирование бэкенд-приложений можно классифицировать по нескольким критериям.

**По типу автоматизации:**
- **Ручные тесты**\
Основными инструментами для бэка является взаимодейстующие приложения (например, фронт или мп),
Postman и Swagger. Суть ясна из названия.

- **Автотесты**\
Те же тесты, но реализованные в коде для автоматического применения локально или в пайпах.
Тут используются либы для написания тестов, моков, создания тестового окружения и т.п.

**По назначению:**

- **Функциональные**\
Проверяют бизнес-логику приложения.

- **Нефункциональные**\
Проверяют производительность, отказоустойчивость, безопасность. 
TODO: Про нефункциональщину можно разузнать побольше и дописать. Относятся ли сюда 
интеграционные тесты?

Для бэкенд-разработчика наиболее актуальными являются смоук-тесты и автотесты.

Для оценки покрытия тестами приложения используется пирамида тестирования. Её суть 
заключается в том, что количество тестов напрямую зависит от уровня их детализации.
Больше всего должно быть написано юнит-тестов. Затем идут интеграционные, затем e2e.

Стоит упомянуть, что хорошей практикой является запуск тестов в **CI/CD** пайплайнах.

**Unit-тесты**
Используются для тестирования одного юнита, т.е. наименьшей рабочей единицы, будь то функция, 
класс или его метод. Есть прикольные вопросы для проверки того, является 
ли тест юнитом:

> - Если тестируемый код натурально общается БД;
> - Или взаимодействует через интернет;
> - Или пользуется файловой системой;
> - Или не может быть запущен параллельно любому другому тесту;
> - Или нужно делать что-либо в окружении, чтобы запустить тесты.
> 
> Если на хотя бы один пункт Вы ответили "да", в таком случае Вы пишете не юнит-тест.

Юнитами покрываем бизнес-логику и утилки. Мокаем внешние слои для запуска.

**Интеграционные тесты**

Используются для проверки взаимодействия приложения с внешними сервисами – БДшками, 
FS, всё, что идёт через инет. Насколько я понимаю, есть разные тактики. Например,
для внешних интеграций проверяется статус-код респонса, а для БД можно также проверять
валидность данных после изменений.

По сути, здесь проверяются только слои, которые взаимодействуют с внешним миром, не 
вся система как в e2e. Для этих тестов необходимо обеспечить окружение.

**End-to-end**

В e2e'шках тестируется вся система полностью. Т.е., для бэкенда флоу представляет собой
деплой на тестовый стенд, где полностью воссоздана система, или такой же полный, но 
локальный деплой и последующие запуски тестов.

